#!/bin/bash

# functions to make and use ecryptfs... umm drives I guess

bad_exit() {
    printf '%b%s \n' '\033[31m' "$1"
    exit 1
}

# check to see if the given ecryptfs setup exists
check_for_ecryptfs() {
    # TODO: make this better
    if  [[ ! -d ${HOME}/${1} ]] \
        || [[ ! -d ${HOME}/.${1} ]] \
        || [[ ! -d ${HOME}/.ecryptfs ]] \
        || [[ ! -e ${HOME}/.ecryptfs/${1}.conf ]] \
        || [[ ! -e ${HOME}/.ecryptfs/${1}.sig ]] \
        || [[ ! -e ${HOME}/.ecryptfs/${1}_wrapped_passphrase ]];
    then
        return 1
    else
        return 0
    fi
}

# these kinda suck
mount_ecrypt_utils() {
    mount.ecryptfs_private "$1" 2>/dev/null || bad_exit "couldn't mount $1"
}

unmount_ecrypt_utils() {
    umount.ecryptfs_private "$1"
}

insert_password() {
    local user_passwd fs_name
    fs_name="/home/chris/.ecryptfs/${1}_wrapped_passphrase"

    printf 'pleas enter the password\n'
    read -resp ' -> ' user_passwd
    printf '\n'

    printf "%s" "$user_passwd" | \
        ecryptfs-insert-wrapped-passphrase-into-keyring \
            "$fs_name" - &>/dev/null \
        || bad_exit 'insert failed'

    unset user_passwd
    return 0
}


mount_existing() {
    insert_password "$1"

    mount_ecrypt_utils "$1"
}

# wrap a new pass phrase
# enter the password twice in to the kernel for both file and file name encryption
# also add the password signature to the ecryptfs config files for mounting
setup_wrapped_password() {
    local user_passwd sig_key config_file passwd_file_name

    passwd_file_name="${HOME}/.ecryptfs/wrapped-passphrase-${1}"

    config_file="$2"

    printf 'pleas provide password \n'
    read -resp ' -> ' user_passwd
    printf '\n'

    # TODO: use gpg instead
    # make a random password to be wrapped
    printf '%s\n%s' \
            "$(od -xAn -N30 -w30 /dev/urandom | sed -e 's|\s*||g')" \
            "$user_passwd" \
        | ecryptfs-wrap-passphrase "$passwd_file_name" \
        || bad_exit "couldn't wrap pass phrase"

    # enter password for file contents encryption
    printf '%s' "$user_passwd" \
        | ecryptfs-insert-wrapped-passphrase-into-keyring \
          "$passwd_file_name" - \
        || bad_exit "couldn't enter password in to key ring"

    # then again for file name encryption and the sig will be extracted
    sig_key="$(
            printf '%s' "$user_passwd" \
            | ecryptfs-insert-wrapped-passphrase-into-keyring \
              "$passwd_file_name" - \
            | sed -r -e 's|.*\[([[:digit:][:alpha:]]+)\].*|\1|'
        )"

    # enter the sig twice in to the config_file
    printf '%s\n%s\n' "$sig_key" "$sig_key" > "$config_file"

    # make sure variable aren't floating around I guess
    unset user_passwd sig_key
    return 0
}

print_encrypt_msg() {
printf 'The ecryptfs %b%s%b is not found

sin will now make it for you

A user password will be enterd twice in to the the kernal key ring,
once to encrypt file contets then another to encrypt file names

' '\033[33m' "$1" '\033[0m'
}

# the main new ecryptfs func
make_new_ecryptfs_file() {
    local ecfs_name up_dir lo_dir config_file

    # get the args
    ecfs_name="$1"
    lo_dir="$2"
    up_dir="$3"

    print_encrypt_msg "$ecfs_name"

    # make the env files
    mkdir "$lo_dir" "$up_dir" "$HOME/.ecryptfs"

    # the config file without ext
    config_file="${HOME}/.ecryptfs/${ecfs_name}"

    # tell ecryptfs where to look
    echo  "$lo_dir $up_dir ecryptfs" > "${config_file}.conf"

    # make a wrapped passwd then add the sigs the ecryptfs sig file
    setup_wrapped_password "$ecfs_name" "${config_file}.sig"

    mount_ecrypt_utils "$ecfs_name"

    # add default setup here here
}
